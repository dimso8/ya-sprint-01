# Спринт 1

## Задача 1
_Предложить решение по разделению фронтенда на микрофронтенды для системы управления контентом_

**Сценарии использования**  
Из описания системы можно выделить следующие пользовательские сценарии:
1. Загрузить новую фотографию.
2. Удалить фотографию.
3. Просмотреть список фотографий.
4. Проставить лайк для фотографии.
5. Снять лайк с фотографии.
6. Создать профиль пользователя.
7. Отредактировать профиль пользователя.
8. Отобразить профиль пользователя.
9. Войти в систему и авторизоваться.

**Стратегия проектирования**  
Исходя из сценариев использования, предлагается использовать стратегию проектирования вертикальная нарезка, т.к. приложение нацелено на богатый пользовательский опыт. Выделяем четыре независимых доменные области по этапам клиентского пути:
1. Общее управление.
2. Авторизация и аутентификация.
3. Работа с фотографиями.
4. Работа с профилями пользователей.

Почему НЕ используем другие стратегии:
1. Автономность команд. Нет потребности использовать различные технологические стеки.
2. Изоляция. Нет потребности в частом обновлении и независимом развертывании.

Таким образом, получаем следующие четыре приложения:
1. Хостовое приложение для загрузки и управления функциональными приложениями.
2. Приложение для работы с фотографиями.
3. Приложение для управления профилем пользователя.
4. Приложение для авторизации и аутентификации.

**Интеграция микрофронтендов**  
Предлагается использовать Run time интеграцию, т.к. мы хотим развертывать фронтенды независимо друг от друга.

**Композиция фронтендоа**  
Планируем использовать клиентскую композицию, т.к. приложение ориентировано на богатый клиентский опыт.

**Инструмент для создания фронтендов**  
В качестве фреймворка предлагается использовать Module Federation. Данный фреймворк имеет следующие плюсы:
* оптимизация загрузки модулей;
* и их независимая разработка.

**Управление состоянием**  
Управлять состоянием планируем на основе API, т.к.:
* у нас микрофронтенды в основном взаимодействуют с бэкендом, а непрямую друг с другом;
* при этом обмен данными достаточно простой;
* нет событий, которые необходимо передавать между приложениями;
* не требуется хранить сложное состояние;
* приложение по сути является приложением класса CMS.

<details>
<summary>Структура каталога и описание компонент</summary> 

```
frontend
├── microfrontend-auth                          // микрофронтенд авторизации
│   ├── src
│   │   ├── blocks                              // стили компонент:
│   │   │   ├── auth-form                       //     форма авторизации
│   │   │   ├── login                           //     форма входа
│   │   │   └── popup                           //     всплывающие формы/окна
│   │   ├── components                          // компоненты:
│   │   │   ├── InfoTooltip.js                  //     подсказка для входа/авторизации
│   │   │   ├── Login.js                        //     вход в стему
│   │   │   └── Register.js                     //     регистрация нового пользователя
│   │   ├── contexts
│   │   │   └── CurrentUserContext.js           // контекст пользователя
│   │   ├── images                              // изображения:
│   │   │   ├── close.svg                       //     закрыть окно
│   │   │   ├── error-icon.svg                  //     иконка ошибки входа/авторизации
│   │   │   └── success-icon.svg                //     иконка успешного входа/авторизации
│   │   ├── utils                               // утилиты:
│   │   │   └── auth.js                         //     авторизации
│   │   ├── vendor                              // шрифты
│   │   ├── App.jsx                             // основное приложение
│   │   ├── index.css                           // стили приложения
│   │   └── index.js                            // точка входа в микрофронтенд
│   ├── compilation.config.js                   // конфиг компиляции
│   ├── package-lock.json                       // автоматически сгенеренный файл зависимостей
│   ├── package.json                            // зависимости и скрипты микрофронтенда
│   └── webpack.config.js                       // настройки webpack
├── microfrontend-card                          // микрофронтенд работы с фото (описаны только отличия)
│   ├── src
│   │   ├── blocks
│   │   │   ├── card                            // стили для отображения фото
│   │   │   ├── places                          // стили для описания мест
│   │   │   └── popup
│   │   ├── components
│   │   │   ├── AddPlacePopup.js                // компонент добавления места
│   │   │   ├── Card.js                         // компонент работы с фото
│   │   │   ├── ImagePopup.js                   // компонетн показа фото
│   │   │   ├── PopupWithForm.js                // компонент всплывающего окна/формы
│   │   │   └── ProtectedRoute.js               // компонент защищеных работы с защищеными рутами
│   │   ├── contexts
│   │   │   └── CurrentUserContext.js
│   │   ├── images
│   │   │   ├── delete-icon.svg                 // иконка удаления фото
│   │   │   ├── like-active.svg                 // иконка "лакнутого" фото
│   │   │   └── like-inactive.svg               // иконка "нелайкнутого" фото
│   │   ├── utils
│   │   │   └── api.js                          // утилиты работы с фото
│   │   ├── vendor
│   │   ├── App.jsx
│   │   ├── index.css
│   │   └── index.js
│   ├── compilation.config.js
│   ├── package-lock.json
│   ├── package.json
│   └── webpack.config.js
├── microfrontend-profile                       // микрофронтенд работы с профилем пользователя (только отличия)
│   ├── src
│   │   ├── blocks
│   │   │   ├── popup
│   │   │   └── profile                         // стили для форм профиля
│   │   ├── components
│   │   │   ├── EditAvatarPopup.js              // компонент редактирования аватара
│   │   │   ├── EditProfilePopup.js             // компонент редактирования профиля
│   │   │   ├── PopupWithForm.js
│   │   │   └── ProtectedRoute.js
│   │   ├── contexts
│   │   │   └── CurrentUserContext.js
│   │   ├── images
│   │   │   └── add-icon.svg                    // иконка "Добавить аватар"
│   │   ├── utils
│   │   │   └── api.js                          // утилиты работы с профилем
│   │   ├── vendor
│   │   ├── App.jsx
│   │   ├── index.css
│   │   └── index.js
│   ├── compilation.config.js
│   ├── package-lock.json
│   ├── package.json
│   └── webpack.config.js
├── public                                      // файлы хостового приложения
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── blocks
│   │   ├── content                             // стили содержимого
│   │   ├── footer                              // стили подножья страницы хоста
│   │   ├── header                              // стили заголовка страницы хоста
│   │   ├── page                                // стили страницы
│   │   └── popup
│   ├── components
│   │   ├── App.js                              // компонент хостового приложения
│   │   ├── Footer.js                           // компонент подножья
│   │   ├── Header.js                           // компонент заголовка
│   │   ├── Main.js                             // компонент оснвной страницы
│   │   └── ProtectedRoute.js
│   ├── contexts
│   │   └── CurrentUserContext.js
│   ├── images
│   │   ├── close.svg                           // иконка выхода
│   │   └── logo.svg                            // лого приложения
│   ├── utils
│   │   └── api.js                              // утилиты хоста
│   ├── vendor
│   ├── index.css
│   ├── index.js
│   ├── logo.svg
│   ├── serviceWorker.js
│   └── setupTests.js
├── index.spec.js
├── package-lock.json
├── package.json
└── webpack.config.js
```  
</details> 

## Задача 2
_Разбить на микросервисы монолитное приложение – систему управления торговыми площадками_

**Предположения** **(assumptions)**  
1. Торговые площадки предлагают разные товары и услуги, поэтому идентификатор торговой площадки – это атрибут товара или услуги.

**Упрощения**  
1. На схеме не отражены взаимодействия сервисов с сервисом аутентификации.
2. Также не показаны служебные сервисы, например, API Gateway/BFF, сервисы преобразования данных, интеграционные сервисы и т.п.
3. Взаимодействие «фронтенд – бекенд» также не показано.

**Описание решения**  
Основная идея декомпозиции – разделить монолитное приложение на сервисы по основным сущностям. В данном примере этот подход почти совпадает с функциональной декомпозицией и дает несколько доменных областей, которые определяют границы будущих микросервисов, а именно:
1. Домен работы с профилем пользователя – сервис «Профиль пользователя» (здесь и далее названия сервисов даны в единственном числе согласно принятому подходу обозначения сущностей на ER-диаграммах). Данный сервис отвечает за жизненный цикл профиля пользователя: от создания до деактивации, а также добавление/удаление предлагаемых пользователем услуг или товаров.
2. Домен работы с товарами и услугами – сервис «Каталог товаров и услуг». Отвечает за жизненный цикл товаров и услуг.
3. Домен работы с аукционами – сервис «Аукцион». Работает так же с заявками на аукцион и со ставками. Предполагается, что ставок может быть несколько. Ставка-победитель сохраняется в запись об аукционе. Пользователь-покупатель – это пользователь, который создал аукцион. Пользователь-продавец – пользователь, чья ставка победила.
4. Домен работы с заказами – сервис «Заказ». Реализует жизненный цикл заказа.
5. Домен работы с платежами – сервис «Платежный хаб». Управляет платежными операциями и взаимодействием с платежными системами.
6. Домен работы с обращениями пользователей – сервис «Запрос в поддержку». Управляет жизненным циклом обращений пользователей.
7. Домен работы с апелляциями – сервис «Апелляция». Аналогично управляет жизненным циклом апелляций.
8. И служебный сервис аутентификации.

**Потоки данных**  
Предлагается свести взаимодействие прямое взаимодействие сервисов к минимуму. Вся передача данных должна осуществляться через фронт. Например, когда пользователь хочет оформить заказ из каталога, то все необходимые для формирования заказа данные по товару или услуге уже есть на фронте. Таким образом, фронт может создать заказ, вызывая методы соответствующего сервиса и передать в параметрах данные товаров и/или услуг.

Исключениями будут случаи, когда workflow нельзя разбить на этапы, границы которых НЕ проходят в зоне ответственности интерфейса пользователя. Например, если мы хотим сформировать в карточку пользователе на беке и сразу подтянуть в нее информацию о товарах и услугах, которые пользователь предлагает. Или когда есть асинхронное взаимодействие по информированию одного сервиса другим.

Таким образом получаем потоки внутри приложения:
* A1, A3, A5 – запрос данных по товару или услуге;
* A2, A4, A6 – ответ с данными по товару или услуге;
* B1 – запрос на создание заказа при автоматическом определении победителя аукциона;
* B2 – идентификатор нового заказа;
* C1 – нотификация об изменении статуса платежной операции, связанной с заказом.

Внешние потоки остаются без изменений.

Ссылка на схему: [arch_template_task2-v4.drawio][def]

[def]: ./arch_template_task2-v4.drawio